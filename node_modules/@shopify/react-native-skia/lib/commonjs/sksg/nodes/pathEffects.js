"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makePath2DPathEffect = exports.makePath1DPathEffect = exports.makeLine2DPathEffect = exports.makeDiscretePathEffect = exports.makeDashPathEffect = exports.makeCornerPathEffect = exports.declareSumPathEffect = exports.composePathEffects = void 0;
var _nodes = require("../../dom/nodes");
var _types = require("../../skia/types");
var _DeclarationContext = require("../DeclarationContext");
const composePathEffects = (ctx, pe, processChildren) => {
  "worklet";

  const {
    Skia
  } = ctx;
  ctx.pathEffects.save();
  processChildren();
  const pe1 = ctx.pathEffects.popAllAsOne();
  ctx.pathEffects.restore();
  ctx.pathEffects.push(pe1 ? Skia.PathEffect.MakeCompose(pe, pe1) : pe);
};
exports.composePathEffects = composePathEffects;
const makeDiscretePathEffect = (ctx, props) => {
  "worklet";

  const {
    length,
    deviation,
    seed
  } = props;
  return ctx.Skia.PathEffect.MakeDiscrete(length, deviation, seed);
};
exports.makeDiscretePathEffect = makeDiscretePathEffect;
const makePath2DPathEffect = (ctx, props) => {
  "worklet";

  const {
    matrix
  } = props;
  const path = (0, _nodes.processPath)(ctx.Skia, props.path);
  const pe = ctx.Skia.PathEffect.MakePath2D(matrix, path);
  if (pe === null) {
    throw new Error("Path2DPathEffect: invalid path");
  }
  return pe;
};
exports.makePath2DPathEffect = makePath2DPathEffect;
const makeDashPathEffect = (ctx, props) => {
  "worklet";

  const {
    intervals,
    phase
  } = props;
  const pe = ctx.Skia.PathEffect.MakeDash(intervals, phase);
  return pe;
};
exports.makeDashPathEffect = makeDashPathEffect;
const makeCornerPathEffect = (ctx, props) => {
  "worklet";

  const {
    r
  } = props;
  const pe = ctx.Skia.PathEffect.MakeCorner(r);
  if (pe === null) {
    throw new Error("CornerPathEffect: couldn't create path effect");
  }
  return pe;
};
exports.makeCornerPathEffect = makeCornerPathEffect;
const declareSumPathEffect = ctx => {
  "worklet";

  // Note: decorateChildren functionality needs to be handled differently
  const pes = ctx.pathEffects.popAll();
  const pe = (0, _DeclarationContext.composeDeclarations)(pes, ctx.Skia.PathEffect.MakeSum.bind(ctx.Skia.PathEffect));
  ctx.pathEffects.push(pe);
};
exports.declareSumPathEffect = declareSumPathEffect;
const makeLine2DPathEffect = (ctx, props) => {
  "worklet";

  const {
    width,
    matrix
  } = props;
  const pe = ctx.Skia.PathEffect.MakeLine2D(width, matrix);
  if (pe === null) {
    throw new Error("Line2DPathEffect: could not create path effect");
  }
  return pe;
};
exports.makeLine2DPathEffect = makeLine2DPathEffect;
const makePath1DPathEffect = (ctx, props) => {
  "worklet";

  const {
    advance,
    phase,
    style
  } = props;
  const path = (0, _nodes.processPath)(ctx.Skia, props.path);
  const pe = ctx.Skia.PathEffect.MakePath1D(path, advance, phase, _types.Path1DEffectStyle[(0, _nodes.enumKey)(style)]);
  if (pe === null) {
    throw new Error("Path1DPathEffect: could not create path effect");
  }
  return pe;
};
exports.makePath1DPathEffect = makePath1DPathEffect;
//# sourceMappingURL=pathEffects.js.map