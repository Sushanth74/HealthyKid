"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.declareTwoPointConicalGradientShader = exports.declareTurbulenceShader = exports.declareSweepGradientShader = exports.declareShader = exports.declareRadialGradientShader = exports.declareLinearGradientShader = exports.declareImageShader = exports.declareFractalNoiseShader = exports.declareColorShader = void 0;
var _nodes = require("../../dom/nodes");
var _types = require("../../skia/types");
const declareShader = (ctx, props) => {
  "worklet";

  const {
    source,
    uniforms,
    ...transform
  } = props;
  const m3 = ctx.Skia.Matrix();
  (0, _nodes.processTransformProps)(m3, transform);
  const shader = source.makeShaderWithChildren((0, _types.processUniforms)(source, uniforms), ctx.shaders.popAll(), m3);
  ctx.shaders.push(shader);
};
exports.declareShader = declareShader;
const declareColorShader = (ctx, props) => {
  "worklet";

  const {
    color
  } = props;
  const shader = ctx.Skia.Shader.MakeColor(ctx.Skia.Color(color));
  ctx.shaders.push(shader);
};
exports.declareColorShader = declareColorShader;
const declareFractalNoiseShader = (ctx, props) => {
  "worklet";

  const {
    freqX,
    freqY,
    octaves,
    seed,
    tileWidth,
    tileHeight
  } = props;
  const shader = ctx.Skia.Shader.MakeFractalNoise(freqX, freqY, octaves, seed, tileWidth, tileHeight);
  ctx.shaders.push(shader);
};
exports.declareFractalNoiseShader = declareFractalNoiseShader;
const declareTwoPointConicalGradientShader = (ctx, props) => {
  "worklet";

  const {
    startR,
    endR,
    start,
    end
  } = props;
  const {
    colors,
    positions,
    mode,
    localMatrix,
    flags
  } = (0, _nodes.processGradientProps)(ctx.Skia, props);
  const shader = ctx.Skia.Shader.MakeTwoPointConicalGradient(start, startR, end, endR, colors, positions, mode, localMatrix, flags);
  ctx.shaders.push(shader);
};
exports.declareTwoPointConicalGradientShader = declareTwoPointConicalGradientShader;
const declareRadialGradientShader = (ctx, props) => {
  "worklet";

  const {
    c,
    r
  } = props;
  const {
    colors,
    positions,
    mode,
    localMatrix,
    flags
  } = (0, _nodes.processGradientProps)(ctx.Skia, props);
  const shader = ctx.Skia.Shader.MakeRadialGradient(c, r, colors, positions, mode, localMatrix, flags);
  ctx.shaders.push(shader);
};
exports.declareRadialGradientShader = declareRadialGradientShader;
const declareSweepGradientShader = (ctx, props) => {
  "worklet";

  const {
    c,
    start,
    end
  } = props;
  const {
    colors,
    positions,
    mode,
    localMatrix,
    flags
  } = (0, _nodes.processGradientProps)(ctx.Skia, props);
  const shader = ctx.Skia.Shader.MakeSweepGradient(c.x, c.y, colors, positions, mode, localMatrix, flags, start, end);
  ctx.shaders.push(shader);
};
exports.declareSweepGradientShader = declareSweepGradientShader;
const declareLinearGradientShader = (ctx, props) => {
  "worklet";

  const {
    start,
    end
  } = props;
  const {
    colors,
    positions,
    mode,
    localMatrix,
    flags
  } = (0, _nodes.processGradientProps)(ctx.Skia, props);
  const shader = ctx.Skia.Shader.MakeLinearGradient(start, end, colors, positions !== null && positions !== void 0 ? positions : null, mode, localMatrix, flags);
  ctx.shaders.push(shader);
};
exports.declareLinearGradientShader = declareLinearGradientShader;
const declareTurbulenceShader = (ctx, props) => {
  "worklet";

  const {
    freqX,
    freqY,
    octaves,
    seed,
    tileWidth,
    tileHeight
  } = props;
  const shader = ctx.Skia.Shader.MakeTurbulence(freqX, freqY, octaves, seed, tileWidth, tileHeight);
  ctx.shaders.push(shader);
};
exports.declareTurbulenceShader = declareTurbulenceShader;
const declareImageShader = (ctx, props) => {
  "worklet";

  const {
    fit,
    image,
    tx,
    ty,
    fm,
    mm,
    ...imageShaderProps
  } = props;
  if (!image) {
    return;
  }
  const rct = (0, _nodes.getRect)(ctx.Skia, imageShaderProps);
  const m3 = ctx.Skia.Matrix();
  if (rct) {
    const rects = (0, _nodes.fitRects)(fit, {
      x: 0,
      y: 0,
      width: image.width(),
      height: image.height()
    }, rct);
    const [x, y, sx, sy] = (0, _nodes.rect2rect)(rects.src, rects.dst);
    m3.translate(x.translateX, y.translateY);
    m3.scale(sx.scaleX, sy.scaleY);
  }
  const lm = ctx.Skia.Matrix();
  lm.concat(m3);
  (0, _nodes.processTransformProps)(lm, imageShaderProps);
  const shader = image.makeShaderOptions(_types.TileMode[(0, _nodes.enumKey)(tx)], _types.TileMode[(0, _nodes.enumKey)(ty)], _types.FilterMode[(0, _nodes.enumKey)(fm)], _types.MipmapMode[(0, _nodes.enumKey)(mm)], lm);
  ctx.shaders.push(shader);
};
exports.declareImageShader = declareImageShader;
//# sourceMappingURL=shaders.js.map