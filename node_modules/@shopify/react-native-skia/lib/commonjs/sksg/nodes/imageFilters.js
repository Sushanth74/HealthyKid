"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeRuntimeShaderImageFilter = exports.makeOffsetImageFilter = exports.makeMorphologyImageFilter = exports.makeDropShadowImageFilter = exports.makeBlurImageFilter = exports.declareDisplacementMapImageFilter = exports.declareBlurMaskFilter = exports.declareBlendImageFilter = exports.declareBlend = exports.composeImageFilters = exports.MorphologyOperator = void 0;
var _nodes = require("../../dom/nodes");
var _types = require("../../skia/types");
var _DeclarationContext = require("../DeclarationContext");
let MorphologyOperator = exports.MorphologyOperator = /*#__PURE__*/function (MorphologyOperator) {
  MorphologyOperator[MorphologyOperator["Erode"] = 0] = "Erode";
  MorphologyOperator[MorphologyOperator["Dilate"] = 1] = "Dilate";
  return MorphologyOperator;
}({});
const Black = Float32Array.of(0, 0, 0, 1);
const MakeInnerShadow = (Skia, shadowOnly, dx, dy, sigmaX, sigmaY, color, input) => {
  "worklet";

  const sourceGraphic = Skia.ImageFilter.MakeColorFilter(Skia.ColorFilter.MakeBlend(Black, _types.BlendMode.Dst), null);
  const sourceAlpha = Skia.ImageFilter.MakeColorFilter(Skia.ColorFilter.MakeBlend(Black, _types.BlendMode.SrcIn), null);
  const f1 = Skia.ImageFilter.MakeColorFilter(Skia.ColorFilter.MakeBlend(color, _types.BlendMode.SrcOut), null);
  const f2 = Skia.ImageFilter.MakeOffset(dx, dy, f1);
  const f3 = Skia.ImageFilter.MakeBlur(sigmaX, sigmaY, _types.TileMode.Decal, f2);
  const f4 = Skia.ImageFilter.MakeBlend(_types.BlendMode.SrcIn, sourceAlpha, f3);
  if (shadowOnly) {
    return f4;
  }
  return Skia.ImageFilter.MakeCompose(input, Skia.ImageFilter.MakeBlend(_types.BlendMode.SrcOver, sourceGraphic, f4));
};
const declareBlend = (ctx, props) => {
  "worklet";

  const {
    Skia
  } = ctx;
  const blend = _types.BlendMode[(0, _nodes.enumKey)(props.mode)];
  // Blend ImageFilters
  const imageFilters = ctx.imageFilters.popAll();
  if (imageFilters.length > 0) {
    const composer = Skia.ImageFilter.MakeBlend.bind(Skia.ImageFilter, blend);
    ctx.imageFilters.push((0, _DeclarationContext.composeDeclarations)(imageFilters, composer));
  }
  // Blend Shaders
  const shaders = ctx.shaders.popAll();
  if (shaders.length > 0) {
    const composer = Skia.Shader.MakeBlend.bind(Skia.Shader, blend);
    ctx.shaders.push((0, _DeclarationContext.composeDeclarations)(shaders, composer));
  }
};
exports.declareBlend = declareBlend;
const composeImageFilters = (ctx, imgf1, processChildren) => {
  "worklet";

  const {
    Skia
  } = ctx;
  ctx.imageFilters.save();
  ctx.colorFilters.save();
  processChildren();
  let imgf2 = ctx.imageFilters.popAllAsOne();
  const cf = ctx.colorFilters.popAllAsOne();
  ctx.imageFilters.restore();
  ctx.colorFilters.restore();
  if (cf) {
    var _imgf;
    imgf2 = Skia.ImageFilter.MakeCompose((_imgf = imgf2) !== null && _imgf !== void 0 ? _imgf : null, Skia.ImageFilter.MakeColorFilter(cf, null));
  }
  const imgf = imgf2 ? Skia.ImageFilter.MakeCompose(imgf1, imgf2) : imgf1;
  ctx.imageFilters.push(imgf);
};
exports.composeImageFilters = composeImageFilters;
const input = ctx => {
  "worklet";

  var _ctx$imageFilters$pop;
  return (_ctx$imageFilters$pop = ctx.imageFilters.pop()) !== null && _ctx$imageFilters$pop !== void 0 ? _ctx$imageFilters$pop : null;
};
const makeOffsetImageFilter = (ctx, props) => {
  "worklet";

  const {
    x,
    y
  } = props;
  return ctx.Skia.ImageFilter.MakeOffset(x, y, null);
};
exports.makeOffsetImageFilter = makeOffsetImageFilter;
const declareDisplacementMapImageFilter = (ctx, props) => {
  "worklet";

  const {
    channelX,
    channelY,
    scale
  } = props;
  const shader = ctx.shaders.pop();
  if (!shader) {
    throw new Error("DisplacementMap expects a shader as child");
  }
  const map = ctx.Skia.ImageFilter.MakeShader(shader, null);
  const imgf = ctx.Skia.ImageFilter.MakeDisplacementMap(_types.ColorChannel[(0, _nodes.enumKey)(channelX)], _types.ColorChannel[(0, _nodes.enumKey)(channelY)], scale, map, input(ctx));
  ctx.imageFilters.push(imgf);
};
exports.declareDisplacementMapImageFilter = declareDisplacementMapImageFilter;
const makeBlurImageFilter = (ctx, props) => {
  "worklet";

  const {
    mode,
    blur
  } = props;
  const sigma = (0, _nodes.processRadius)(ctx.Skia, blur);
  const imgf = ctx.Skia.ImageFilter.MakeBlur(sigma.x, sigma.y, _types.TileMode[(0, _nodes.enumKey)(mode)], input(ctx));
  return imgf;
};
exports.makeBlurImageFilter = makeBlurImageFilter;
const makeDropShadowImageFilter = (ctx, props) => {
  "worklet";

  const {
    dx,
    dy,
    blur,
    shadowOnly,
    color: cl,
    inner
  } = props;
  const color = ctx.Skia.Color(cl);
  let factory;
  if (inner) {
    factory = MakeInnerShadow.bind(null, ctx.Skia, shadowOnly);
  } else {
    factory = shadowOnly ? ctx.Skia.ImageFilter.MakeDropShadowOnly.bind(ctx.Skia.ImageFilter) : ctx.Skia.ImageFilter.MakeDropShadow.bind(ctx.Skia.ImageFilter);
  }
  const imgf = factory(dx, dy, blur, blur, color, input(ctx));
  return imgf;
};
exports.makeDropShadowImageFilter = makeDropShadowImageFilter;
const makeMorphologyImageFilter = (ctx, props) => {
  "worklet";

  const {
    operator
  } = props;
  const r = (0, _nodes.processRadius)(ctx.Skia, props.radius);
  let imgf;
  if (MorphologyOperator[(0, _nodes.enumKey)(operator)] === MorphologyOperator.Erode) {
    imgf = ctx.Skia.ImageFilter.MakeErode(r.x, r.y, input(ctx));
  } else {
    imgf = ctx.Skia.ImageFilter.MakeDilate(r.x, r.y, input(ctx));
  }
  return imgf;
};
exports.makeMorphologyImageFilter = makeMorphologyImageFilter;
const makeRuntimeShaderImageFilter = (ctx, props) => {
  "worklet";

  const {
    source,
    uniforms
  } = props;
  const rtb = ctx.Skia.RuntimeShaderBuilder(source);
  if (uniforms) {
    (0, _types.processUniforms)(source, uniforms, rtb);
  }
  const imgf = ctx.Skia.ImageFilter.MakeRuntimeShader(rtb, null, input(ctx));
  return imgf;
};
exports.makeRuntimeShaderImageFilter = makeRuntimeShaderImageFilter;
const declareBlendImageFilter = (ctx, props) => {
  "worklet";

  const {
    mode
  } = props;
  const a = ctx.imageFilters.pop();
  const b = ctx.imageFilters.pop();
  if (!a || !b) {
    throw new Error("BlendImageFilter requires two image filters");
  }
  const imgf = ctx.Skia.ImageFilter.MakeBlend(mode, a, b);
  ctx.imageFilters.push(imgf);
};
exports.declareBlendImageFilter = declareBlendImageFilter;
const declareBlurMaskFilter = (ctx, props) => {
  "worklet";

  const {
    blur,
    style,
    respectCTM
  } = props;
  const mf = ctx.Skia.MaskFilter.MakeBlur(_types.BlurStyle[(0, _nodes.enumKey)(style)], blur, respectCTM);
  ctx.maskFilters.push(mf);
};
exports.declareBlurMaskFilter = declareBlurMaskFilter;
//# sourceMappingURL=imageFilters.js.map