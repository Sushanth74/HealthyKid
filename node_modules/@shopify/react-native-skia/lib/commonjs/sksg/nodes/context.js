"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.draw = draw;
var _types = require("../../dom/types");
var _DeclarationContext = require("../DeclarationContext");
var _drawings = require("./drawings");
var _colorFilters = require("./colorFilters");
var _imageFilters = require("./imageFilters");
var _utils = require("./utils");
var _shaders = require("./shaders");
var _paint = require("./paint");
var _pathEffects = require("./pathEffects");
/* eslint-disable @typescript-eslint/no-explicit-any */

function processDeclarations(ctx, node) {
  "worklet";

  const processChildren = () => node.children.forEach(child => processDeclarations(ctx, child));
  const {
    type
  } = node;
  const props = (0, _utils.materialize)(node.props);
  switch (type) {
    // Mask Filter
    case _types.NodeType.BlurMaskFilter:
      {
        (0, _imageFilters.declareBlurMaskFilter)(ctx, props);
        break;
      }
    // Color Filters
    case _types.NodeType.LerpColorFilter:
      {
        processChildren();
        (0, _colorFilters.declareLerpColorFilter)(ctx, props);
        break;
      }
    case _types.NodeType.Blend:
      {
        processChildren();
        (0, _imageFilters.declareBlend)(ctx, props);
        break;
      }
    case _types.NodeType.BlendColorFilter:
      {
        const cf = (0, _colorFilters.makeBlendColorFilter)(ctx, props);
        (0, _colorFilters.composeColorFilters)(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.SRGBToLinearGammaColorFilter:
      {
        const cf = (0, _colorFilters.makeSRGBToLinearGammaColorFilter)(ctx);
        (0, _colorFilters.composeColorFilters)(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.LinearToSRGBGammaColorFilter:
      {
        const cf = (0, _colorFilters.makeLinearToSRGBGammaColorFilter)(ctx);
        (0, _colorFilters.composeColorFilters)(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.MatrixColorFilter:
      {
        const cf = (0, _colorFilters.makeMatrixColorFilter)(ctx, props);
        (0, _colorFilters.composeColorFilters)(ctx, cf, processChildren);
        break;
      }
    case _types.NodeType.LumaColorFilter:
      {
        const cf = (0, _colorFilters.makeLumaColorFilter)(ctx);
        (0, _colorFilters.composeColorFilters)(ctx, cf, processChildren);
        break;
      }
    // Shaders
    case _types.NodeType.Shader:
      {
        processChildren();
        (0, _shaders.declareShader)(ctx, props);
        break;
      }
    case _types.NodeType.ImageShader:
      {
        (0, _shaders.declareImageShader)(ctx, props);
        break;
      }
    case _types.NodeType.ColorShader:
      {
        (0, _shaders.declareColorShader)(ctx, props);
        break;
      }
    case _types.NodeType.Turbulence:
      {
        (0, _shaders.declareTurbulenceShader)(ctx, props);
        break;
      }
    case _types.NodeType.FractalNoise:
      {
        (0, _shaders.declareFractalNoiseShader)(ctx, props);
        break;
      }
    case _types.NodeType.LinearGradient:
      {
        (0, _shaders.declareLinearGradientShader)(ctx, props);
        break;
      }
    case _types.NodeType.RadialGradient:
      {
        (0, _shaders.declareRadialGradientShader)(ctx, props);
        break;
      }
    case _types.NodeType.SweepGradient:
      {
        (0, _shaders.declareSweepGradientShader)(ctx, props);
        break;
      }
    case _types.NodeType.TwoPointConicalGradient:
      {
        (0, _shaders.declareTwoPointConicalGradientShader)(ctx, props);
        break;
      }
    // Image Filters
    case _types.NodeType.BlurImageFilter:
      {
        const imgf = (0, _imageFilters.makeBlurImageFilter)(ctx, props);
        (0, _imageFilters.composeImageFilters)(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.OffsetImageFilter:
      {
        const imgf = (0, _imageFilters.makeOffsetImageFilter)(ctx, props);
        (0, _imageFilters.composeImageFilters)(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.DisplacementMapImageFilter:
      {
        processChildren();
        (0, _imageFilters.declareDisplacementMapImageFilter)(ctx, props);
        break;
      }
    case _types.NodeType.DropShadowImageFilter:
      {
        const imgf = (0, _imageFilters.makeDropShadowImageFilter)(ctx, props);
        (0, _imageFilters.composeImageFilters)(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.MorphologyImageFilter:
      {
        const imgf = (0, _imageFilters.makeMorphologyImageFilter)(ctx, props);
        (0, _imageFilters.composeImageFilters)(ctx, imgf, processChildren);
        break;
      }
    case _types.NodeType.BlendImageFilter:
      {
        processChildren();
        (0, _imageFilters.declareBlendImageFilter)(ctx, props);
        break;
      }
    case _types.NodeType.RuntimeShaderImageFilter:
      {
        const imgf = (0, _imageFilters.makeRuntimeShaderImageFilter)(ctx, props);
        (0, _imageFilters.composeImageFilters)(ctx, imgf, processChildren);
        break;
      }
    // Path Effects
    case _types.NodeType.SumPathEffect:
      {
        processChildren();
        (0, _pathEffects.declareSumPathEffect)(ctx);
        break;
      }
    case _types.NodeType.CornerPathEffect:
      {
        const pf = (0, _pathEffects.makeCornerPathEffect)(ctx, props);
        (0, _pathEffects.composePathEffects)(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.Path1DPathEffect:
      {
        const pf = (0, _pathEffects.makePath1DPathEffect)(ctx, props);
        (0, _pathEffects.composePathEffects)(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.Path2DPathEffect:
      {
        const pf = (0, _pathEffects.makePath2DPathEffect)(ctx, props);
        (0, _pathEffects.composePathEffects)(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.Line2DPathEffect:
      {
        const pf = (0, _pathEffects.makeLine2DPathEffect)(ctx, props);
        (0, _pathEffects.composePathEffects)(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.DashPathEffect:
      {
        const pf = (0, _pathEffects.makeDashPathEffect)(ctx, props);
        (0, _pathEffects.composePathEffects)(ctx, pf, processChildren);
        break;
      }
    case _types.NodeType.DiscretePathEffect:
      {
        const pf = (0, _pathEffects.makeDiscretePathEffect)(ctx, props);
        (0, _pathEffects.composePathEffects)(ctx, pf, processChildren);
        break;
      }
    // Paint
    case _types.NodeType.Paint:
      processChildren();
      (0, _paint.declarePaint)(ctx, props);
      break;
    default:
      console.log("Unknown declaration node: ", type);
  }
}
const preProcessContext = (ctx, props, node) => {
  "worklet";

  const shouldRestoreMatrix = ctx.processMatrixAndClipping(props, props.layer);
  const declCtx = (0, _DeclarationContext.createDeclarationContext)(ctx.Skia);
  node.children.forEach(child => {
    if (child.isDeclaration) {
      processDeclarations(declCtx, child);
    }
  });
  const shouldRestorePaint = ctx.processPaint(props, declCtx);
  return {
    shouldRestoreMatrix,
    shouldRestorePaint,
    extraPaints: declCtx.paints.popAll()
  };
};
const drawBackdropFilter = (ctx, node) => {
  "worklet";

  const {
    canvas,
    Skia
  } = ctx;
  const child = node.children[0];
  let imageFilter = null;
  if (child.isDeclaration) {
    const declCtx = (0, _DeclarationContext.createDeclarationContext)(ctx.Skia);
    processDeclarations(declCtx, child);
    const imgf = declCtx.imageFilters.pop();
    if (imgf) {
      imageFilter = imgf;
    } else {
      const cf = declCtx.colorFilters.pop();
      if (cf) {
        imageFilter = Skia.ImageFilter.MakeColorFilter(cf, null);
      }
    }
  }
  canvas.saveLayer(undefined, null, imageFilter);
  canvas.restore();
};
function draw(ctx, node) {
  "worklet";

  // Special mixed nodes
  if (node.type === _types.NodeType.BackdropFilter) {
    drawBackdropFilter(ctx, node);
    return;
  }
  if (node.type === _types.NodeType.Layer) {
    let hasLayer = false;
    const [layer, ...children] = node.children;
    if (layer.isDeclaration) {
      const declCtx = (0, _DeclarationContext.createDeclarationContext)(ctx.Skia);
      processDeclarations(declCtx, layer);
      const paint = declCtx.paints.pop();
      if (paint) {
        hasLayer = true;
        ctx.canvas.saveLayer(paint);
      }
    }
    children.map(child => {
      if (!child.isDeclaration) {
        draw(ctx, child);
      }
    });
    if (hasLayer) {
      ctx.canvas.restore();
    }
    return;
  }
  const {
    type,
    props: rawProps,
    children
  } = node;
  // Regular nodes
  const props = (0, _utils.materialize)(rawProps);
  const {
    shouldRestoreMatrix,
    shouldRestorePaint,
    extraPaints
  } = preProcessContext(ctx, props, node);
  const paints = [ctx.getPaint(), ...extraPaints];
  paints.forEach(paint => {
    const lctx = {
      paint,
      Skia: ctx.Skia,
      canvas: ctx.canvas
    };
    switch (type) {
      case _types.NodeType.Box:
        (0, _drawings.drawBox)(lctx, props, node.children);
        break;
      case _types.NodeType.Image:
        (0, _drawings.drawImage)(lctx, props);
        break;
      case _types.NodeType.Points:
        (0, _drawings.drawPoints)(lctx, props);
        break;
      case _types.NodeType.Path:
        (0, _drawings.drawPath)(lctx, props);
        break;
      case _types.NodeType.Rect:
        (0, _drawings.drawRect)(lctx, props);
        break;
      case _types.NodeType.RRect:
        (0, _drawings.drawRRect)(lctx, props);
        break;
      case _types.NodeType.Oval:
        (0, _drawings.drawOval)(lctx, props);
        break;
      case _types.NodeType.Line:
        (0, _drawings.drawLine)(lctx, props);
        break;
      case _types.NodeType.Patch:
        (0, _drawings.drawPatch)(lctx, props);
        break;
      case _types.NodeType.Vertices:
        (0, _drawings.drawVertices)(lctx, props);
        break;
      case _types.NodeType.DiffRect:
        (0, _drawings.drawDiffRect)(lctx, props);
        break;
      case _types.NodeType.Text:
        (0, _drawings.drawText)(lctx, props);
        break;
      case _types.NodeType.TextPath:
        (0, _drawings.drawTextPath)(lctx, props);
        break;
      case _types.NodeType.TextBlob:
        (0, _drawings.drawTextBlob)(lctx, props);
        break;
      case _types.NodeType.Glyphs:
        (0, _drawings.drawGlyphs)(lctx, props);
        break;
      case _types.NodeType.Picture:
        (0, _drawings.drawPicture)(lctx, props);
        break;
      case _types.NodeType.ImageSVG:
        (0, _drawings.drawImageSVG)(lctx, props);
        break;
      case _types.NodeType.Paragraph:
        (0, _drawings.drawParagraph)(lctx, props);
        break;
      case _types.NodeType.Atlas:
        (0, _drawings.drawAtlas)(lctx, props);
        break;
      case _types.NodeType.Circle:
        (0, _drawings.drawCircle)(lctx, props);
        break;
      case _types.NodeType.Fill:
        (0, _drawings.drawFill)(lctx, props);
        break;
      case _types.NodeType.Group:
        // TODO: do nothing
        break;
      default:
        if (!node.isDeclaration) {
          console.warn(`Unsupported node type: ${type}`);
        }
    }
  });
  children.forEach(child => {
    if (!child.isDeclaration) {
      draw(ctx, child);
    }
  });
  if (shouldRestoreMatrix) {
    ctx.canvas.restore();
  }
  if (shouldRestorePaint) {
    ctx.restore();
  }
}
//# sourceMappingURL=context.js.map