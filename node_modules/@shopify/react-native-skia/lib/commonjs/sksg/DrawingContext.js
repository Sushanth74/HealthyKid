"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDrawingContext = void 0;
var _nodes = require("../dom/nodes");
var _types = require("../skia/types");
const computeClip = (Skia, clip) => {
  "worklet";

  if (clip) {
    if ((0, _nodes.isPathDef)(clip)) {
      return {
        clipPath: (0, _nodes.processPath)(Skia, clip)
      };
    } else if ((0, _types.isRRect)(clip)) {
      return {
        clipRRect: clip
      };
    } else {
      return {
        clipRect: clip
      };
    }
  }
  return undefined;
};
const processColor = (Skia, color) => {
  "worklet";

  if (typeof color === "string" || typeof color === "number") {
    return Skia.Color(color);
  } else if (Array.isArray(color) || color instanceof Float32Array) {
    return color instanceof Float32Array ? color : new Float32Array(color);
  } else {
    throw new Error(`Invalid color type: ${typeof color}. Expected number, string, or array.`);
  }
};
const createDrawingContext = (Skia, canvas) => {
  "worklet";

  const state = {
    paints: [Skia.Paint()]
  };
  const getPaint = () => {
    return state.paints[state.paints.length - 1];
  };
  const processPaint = ({
    opacity,
    color,
    strokeWidth,
    blendMode,
    style,
    strokeJoin,
    strokeCap,
    strokeMiter,
    antiAlias,
    dither,
    paint: paintProp
  }, declCtx) => {
    if (paintProp) {
      declCtx.paints.push(paintProp);
      return true;
    }
    let shouldRestore = false;
    const colorFilter = declCtx.colorFilters.popAllAsOne();
    const imageFilter = declCtx.imageFilters.popAllAsOne();
    const shader = declCtx.shaders.pop();
    const maskFilter = declCtx.maskFilters.pop();
    const pathEffect = declCtx.pathEffects.popAllAsOne();
    if (opacity !== undefined || color !== undefined || strokeWidth !== undefined || blendMode !== undefined || style !== undefined || strokeJoin !== undefined || strokeCap !== undefined || strokeMiter !== undefined || antiAlias !== undefined || dither !== undefined || colorFilter !== undefined || imageFilter !== undefined || shader !== undefined || maskFilter !== undefined || pathEffect !== undefined) {
      if (!shouldRestore) {
        state.paints.push(getPaint().copy());
        shouldRestore = true;
      }
    }
    const paint = getPaint();
    if (opacity !== undefined) {
      paint.setAlphaf(paint.getAlphaf() * opacity);
    }
    if (color !== undefined) {
      const currentOpacity = paint.getAlphaf();
      paint.setShader(null);
      paint.setColor(processColor(Skia, color));
      paint.setAlphaf(currentOpacity * paint.getAlphaf());
    }
    if (strokeWidth !== undefined) {
      paint.setStrokeWidth(strokeWidth);
    }
    if (blendMode !== undefined) {
      paint.setBlendMode(_types.BlendMode[(0, _nodes.enumKey)(blendMode)]);
    }
    if (style !== undefined) {
      paint.setStyle(_types.PaintStyle[(0, _nodes.enumKey)(style)]);
    }
    if (strokeJoin !== undefined) {
      paint.setStrokeJoin(_types.StrokeJoin[(0, _nodes.enumKey)(strokeJoin)]);
    }
    if (strokeCap !== undefined) {
      paint.setStrokeCap(_types.StrokeCap[(0, _nodes.enumKey)(strokeCap)]);
    }
    if (strokeMiter !== undefined) {
      paint.setStrokeMiter(strokeMiter);
    }
    if (antiAlias !== undefined) {
      paint.setAntiAlias(antiAlias);
    }
    if (dither !== undefined) {
      paint.setDither(dither);
    }
    if (colorFilter) {
      paint.setColorFilter(colorFilter);
    }
    if (imageFilter) {
      paint.setImageFilter(imageFilter);
    }
    if (shader) {
      paint.setShader(shader);
    }
    if (maskFilter) {
      paint.setMaskFilter(maskFilter);
    }
    if (pathEffect) {
      paint.setPathEffect(pathEffect);
    }
    return shouldRestore;
  };
  const processMatrixAndClipping = (props, layer) => {
    const hasTransform = props.matrix !== undefined || props.transform !== undefined;
    const clip = computeClip(Skia, props.clip);
    const hasClip = clip !== undefined;
    const op = props.invertClip ? _types.ClipOp.Difference : _types.ClipOp.Intersect;
    const m3 = (0, _nodes.processTransformProps2)(Skia, props);
    const shouldSave = hasTransform || hasClip || !!layer;
    if (shouldSave) {
      if (layer) {
        if (typeof layer === "boolean") {
          canvas.saveLayer();
        } else {
          canvas.saveLayer(layer);
        }
      } else {
        canvas.save();
      }
    }
    if (m3) {
      canvas.concat(m3);
    }
    if (clip) {
      if ("clipRect" in clip) {
        canvas.clipRect(clip.clipRect, op, true);
      } else if ("clipRRect" in clip) {
        canvas.clipRRect(clip.clipRRect, op, true);
      } else {
        canvas.clipPath(clip.clipPath, op, true);
      }
    }
    return shouldSave;
  };
  return {
    Skia,
    canvas,
    save: () => state.paints.push(getPaint().copy()),
    restore: () => state.paints.pop(),
    getPaint,
    processPaint,
    processMatrixAndClipping
  };
};
exports.createDrawingContext = createDrawingContext;
//# sourceMappingURL=DrawingContext.js.map