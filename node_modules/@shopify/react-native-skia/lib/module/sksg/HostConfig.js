/*global NodeJS*/

import { DefaultEventPriority } from "react-reconciler/constants";
import { NodeType } from "../dom/types";
import { shallowEq } from "../renderer/typeddash";
const DEBUG = false;
export const debug = (...args) => {
  if (DEBUG) {
    console.log(...args);
  }
};
const isDeclaration = type => {
  "worklet";

  return (
    // BlurMaskFilters
    type === NodeType.BlurMaskFilter ||
    // ImageFilters
    type === NodeType.BlendImageFilter || type === NodeType.BlurImageFilter || type === NodeType.OffsetImageFilter || type === NodeType.DropShadowImageFilter || type === NodeType.MorphologyImageFilter || type === NodeType.DisplacementMapImageFilter || type === NodeType.RuntimeShaderImageFilter ||
    // ColorFilters
    type === NodeType.MatrixColorFilter || type === NodeType.BlendColorFilter || type === NodeType.LumaColorFilter || type === NodeType.LinearToSRGBGammaColorFilter || type === NodeType.SRGBToLinearGammaColorFilter || type === NodeType.LerpColorFilter ||
    // Shaders
    type === NodeType.Shader || type === NodeType.ImageShader || type === NodeType.ColorShader || type === NodeType.Turbulence || type === NodeType.FractalNoise || type === NodeType.LinearGradient || type === NodeType.RadialGradient || type === NodeType.SweepGradient || type === NodeType.TwoPointConicalGradient ||
    // Path Effects
    type === NodeType.CornerPathEffect || type === NodeType.DiscretePathEffect || type === NodeType.DashPathEffect || type === NodeType.Path1DPathEffect || type === NodeType.Path2DPathEffect || type === NodeType.SumPathEffect || type === NodeType.Line2DPathEffect ||
    // Mixed
    type === NodeType.Blend ||
    // Paint
    type === NodeType.Paint
  );
};
export const sksgHostConfig = {
  /**
   * This function is used by the reconciler in order to calculate current time for prioritising work.
   */
  supportsMutation: false,
  isPrimaryRenderer: false,
  supportsPersistence: true,
  supportsHydration: false,
  //supportsMicrotask: true,
  scheduleTimeout: setTimeout,
  cancelTimeout: clearTimeout,
  noTimeout: -1,
  getRootHostContext: _rootContainerInstance => {
    debug("getRootHostContext");
    return null;
  },
  getChildHostContext(_parentHostContext, _type, _rootContainerInstance) {
    debug("getChildHostContext");
    return null;
  },
  shouldSetTextContent(_type, _props) {
    return false;
  },
  createTextInstance(_text, _rootContainerInstance, _hostContext, _internalInstanceHandle) {
    debug("createTextInstance");
    // return SpanNode({}, text) as SkNode;
    throw new Error("Text nodes are not supported yet");
  },
  createInstance(type, props, container, _hostContext, _internalInstanceHandle) {
    debug("createInstance", type);
    container.registerValues(props);
    const instance = {
      type,
      isDeclaration: isDeclaration(type),
      props,
      children: []
    };
    return instance;
  },
  appendInitialChild(parentInstance, child) {
    parentInstance.children.push(child);
  },
  finalizeInitialChildren(parentInstance, _type, _props, _rootContainerInstance, _hostContext) {
    debug("finalizeInitialChildren", parentInstance);
    return false;
  },
  commitMount() {
    // if finalizeInitialChildren = true
    debug("commitMount");
  },
  prepareForCommit(_containerInfo) {
    debug("prepareForCommit");
    return null;
  },
  resetAfterCommit(container) {
    debug("resetAfterCommit");
    container.redraw();
  },
  getPublicInstance(node) {
    debug("getPublicInstance");
    return node;
  },
  commitTextUpdate: (_textInstance, _oldText, _newText) => {
    //  textInstance.instance = newText;
  },
  clearContainer: container => {
    debug("clearContainer");
    container.clear();
  },
  prepareUpdate(_instance, _type, oldProps, newProps, container, _hostContext) {
    debug("prepareUpdate");
    const propsAreEqual = shallowEq(oldProps, newProps);
    if (propsAreEqual) {
      return null;
    }
    container.unregisterValues(oldProps);
    container.registerValues(newProps);
    return container;
  },
  preparePortalMount: () => {
    debug("preparePortalMount");
  },
  cloneInstance(instance, _updatePayload, _type, _oldProps, newProps, _internalInstanceHandle, keepChildren, _recyclableInstance) {
    debug("cloneInstance");
    return {
      type: instance.type,
      props: newProps,
      children: keepChildren ? [...instance.children] : [],
      isDeclaration: instance.isDeclaration
    };
  },
  createContainerChildSet() {
    debug("createContainerChildSet");
    return [];
  },
  appendChildToContainerChildSet(childSet, child) {
    childSet.push(child);
  },
  finalizeContainerChildren(container, newChildren) {
    debug("finalizeContainerChildren");
    container.root = newChildren;
  },
  replaceContainerChildren(container, newChildren) {
    debug("replaceContainerChildren");
    container.root = newChildren;
  },
  cloneHiddenInstance(_instance, _type, _props) {
    debug("cloneHiddenInstance");
    throw new Error("Not yet implemented.");
  },
  cloneHiddenTextInstance(_instance, _text) {
    debug("cloneHiddenTextInstance");
    throw new Error("Not yet implemented.");
  },
  // see https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
  getCurrentEventPriority: () => DefaultEventPriority,
  beforeActiveInstanceBlur: () => {},
  afterActiveInstanceBlur: () => {},
  detachDeletedInstance: () => {},
  getInstanceFromNode: function (_node) {
    throw new Error("Function not implemented.");
  },
  prepareScopeUpdate: function (_scopeInstance, _instance) {
    throw new Error("Function not implemented.");
  },
  getInstanceFromScope: function (_scopeInstance) {
    throw new Error("Function not implemented.");
  }
};
//# sourceMappingURL=HostConfig.js.map